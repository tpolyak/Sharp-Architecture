//-------------------------------------------------------------------------------------------------
// <auto-generated> 
// Marked as auto-generated so StyleCop will ignore BDD style tests
// </auto-generated>
//-------------------------------------------------------------------------------------------------

#pragma warning disable 169
// ReSharper disable InconsistentNaming
// ReSharper disable UnusedMember.Global
// ReSharper disable UnusedMember.Local

namespace SharpArch.Specifications.SharpArch.Domain
{
    using System;
    using System.IO;
    using System.Runtime.Serialization.Formatters.Binary;

    using global::SharpArch.Domain;
    using Machine.Specifications;

    public class file_cache_specs
    {
        [Subject(typeof(FileCache))]
        public class when_retreiving_an_object_from_the_file_cache
        {
            static object result;
            static DummyType dummy = new DummyType { FirstProperty = "First" };

            Establish context = () =>
            {
                using (FileStream file = File.Open("dummy.txt", FileMode.Create))
                {
                    new BinaryFormatter().Serialize(file, dummy);
                }
            };

            Because of = () => result = FileCache.RetrieveFromCache<DummyType>("dummy.txt");

            It should_return_the_correct_type_of_object = () =>
                result.ShouldBeOfType(typeof(DummyType));

            It should_set_the_objects_properties_correctly = () =>
                ((DummyType)result).FirstProperty.ShouldEqual("First");

            Cleanup after = () => { if (File.Exists("dummy.txt")) File.Delete("dummy.txt"); };
        }

        [Subject(typeof(FileCache))]
        public class when_retreiving_an_object_from_the_file_cache_and_the_file_path_is_empty
        {
            static Exception exception;

            Because of = () => exception = Catch.Exception(() => FileCache.RetrieveFromCache<string>(string.Empty));

            It should_throw_an_argument_exception = () =>
                exception.ShouldBeOfType(typeof(ArgumentException));
        }

        [Subject(typeof(FileCache))]
        public class when_retreiving_an_object_from_the_file_cache_and_the_file_path_is_null
        {
            static Exception exception;

            Because of = () => exception = Catch.Exception(() => FileCache.RetrieveFromCache<string>(null));

            It should_throw_an_argument_exception = () =>
                exception.ShouldBeOfType(typeof(ArgumentException));
        }

        [Subject(typeof(FileCache))]
        public class when_retreiving_an_object_from_the_file_cache_and_the_file_contents_are_invalid
        {
            static object result;

            Establish context = () => File.WriteAllText("dummy.txt", "&&&");

            Because of = () => result = FileCache.RetrieveFromCache<DummyType>("dummy.txt");

            It should_return_null = () => result.ShouldBeNull();

            Cleanup after = () => { if (File.Exists("dummy.txt")) File.Delete("dummy.txt"); };
        }
 
        [Subject(typeof(FileCache))]
        public class when_trying_to_store_a_null_object_in_the_file_cache
        {
            static Exception exception;

            Because of = () => exception = Catch.Exception(() => FileCache.StoreInCache<DummyType>(null, "path.txt"));

            It should_throw_an_argument_exception = () =>
                exception.ShouldBeOfType(typeof(ArgumentException));
        }

        [Subject(typeof(FileCache))]
        public class when_storing_an_object_in_the_file_cache_and_the_file_path_is_empty
        {
            static Exception exception;
            static DummyType dummy = new DummyType();

            Because of = () => exception = Catch.Exception(() => FileCache.StoreInCache<DummyType>(dummy, string.Empty));

            It should_throw_an_argument_exception = () =>
                exception.ShouldBeOfType(typeof(ArgumentException));
        }

        [Subject(typeof(FileCache))]
        public class when_storing_an_object_in_the_file_cache
        {
            static DummyType dummy = new DummyType { FirstProperty = "First" };

            Because of = () => FileCache.StoreInCache<DummyType>(dummy, "dummy.txt");

            It should_serialize_the_object_to_the_file = () => File.Exists("dummy.txt").ShouldBeTrue();

            Cleanup after = () => { if (File.Exists("dummy.txt")) File.Delete("dummy.txt"); };
        }
 
        [Serializable]
        public class DummyType
        {
            public string FirstProperty { get; set; }
        }
    }
}